2016-2-20 周六
===============
今天的工作任务：
1. 摆放配置相关控件并结合软件管理控件
2. 实现配置参数串口通信写入功能
界面功能说明：
从驱动器上传 - 读取驱动器寄存器数值
下载到驱动器 - 向驱动器写入参数值
启动       - 启动或停止运动控制指令

2016-2-22 周一
================
今天编辑了开发文档，提出自己疑问。
上周六半天时间把步进电机调制程序功能界面基本摆放完毕，以及一份说明文档。



2016-4-13 周三
=================
之前关于 将quint8数组转换为QByteArray类型数据问题
使用 append()方法无法实现
后改用 QByteArray operator[] 实现该功能


2016-4-16 周六
==================
换行（NL - next line）对应整型值为10
回车（CR）对应整数值为13

配置用弹出界面提供用户，硬件参数，软件参数
运动控制采用函数库的形式，工具，支持拖拽。
增加硬件参数配置功能

运动控制指令
距离需转换为脉冲数，毫米/一圈
plus =
一圈需要多少脉冲 - 200
百分比*50K =

2016-4-17 周日
===================
功能需求
1、读取配置文件 - 电机机械参数、型号等参数（难度**）
2、主界面功能，指令参数设定、指令拖放、指令序列单步或自动执行（难度*****）
关于参数配置
一方面是下位机配置（通过串口下载到驱动器，也可以回读到页面）
另一方面就是上位机配置（直接放在内存或磁盘上）


2016-4-19 周二
====================
TODO
今晚实现配置文件读取功能

配置包括串口配置、控制器配置、机械参数配置
串口配置写入串口设备缓存
控制器配置通过串口传给控制器
机械参数配置到上位机目录下

2016-4-20 周三
====================
DO
配置数据写入磁盘文件（JSON格式）
TODO
QTableWidget增加数据行

2016-4-26 周二
=====================
编程经验：
不要纠结于界面排版，核心是逻辑和数据结构设计，功能分离
了解一些软件设计模式，比如model/view，视图-展示框架
有想法赶紧去着手实现，时间往往就在徘徊和拖延中流失
功不唐捐，深入了解一个类的接口，都是有益的

2016-4-27 周三
=====================
昨晚认真研究 model/view 设计思路。
model作为数据处理关键，最终通过view展示，而且可以同时展示与不同view
model整理
QStringListModel - 管理QString单元
QStandardItemModel - 管理比较复杂的树结构，可以是任意类型数据
单步对应单步执行指令，单击一次发送一条指令。
自动对应从开始执行到结束为止，中间可以插入跳转指令。

2016-4-28 周四
======================
今晚弄明白 QAbstractItemModel 如何追加一行数据：
model 先插入某行, 然后 setData 该行数据即可

现在的思路是：
初始行变量为0
追加一行，行变量加1，指令序列增加相应指令数
删除一行，行变量减1，指令序列删除相应指令数

单步执行，单击执行按钮从指令序列起始位置发送相应数量指令
自动执行，单击执行按钮指令序列一次性发送，根据下位机返回的数据定位到具体指令行。

2016-5-5 周四
======================



2016-5-7 周六
======================
功能
1、 根据用户输入位置值（绝对或相对）转成脉冲数，
公式：绝对位置/周长 * 1圈脉冲数（200*细分等级）
2、 参数打包需将发送参数写入磁盘持久化
3、 下载打包，可以多次下载



200脉冲 - 1圈
200*细分 = 1圈脉冲数
距离转换脉冲数

2016-5-8 周日
=======================
发布一个软件版本，支持运行指令新增、删除、清空，以及单步运行，下载和停止功能。
一直想完善的指令数据结构、配置指令下载功能，无奈惰性阻力无力抗拒，一直搁浅
接下来的主要工作是继续完成其他指令，如操作、跳转、IO等指令功能
此外，指令修改功能（行选中进行编辑，编辑区仍然是指令区）


2016-5-18 周三
========================
控制器上位机发布beta版后需要改进部分：
1、电流档位和电压边界配置需求修改
2、增加控制主板选配（最大电流与IO端口数等）
3、指令程序持久化，保存为文件形式（比如json文件）

2016-5-20 周五
========================
需求修改
1、电流档位和电压边界自动设置
2、增加控制器选型，最大电流与IO数变更
3、程序指令持久化

1、2以完成，3进行中

2016-5-21 周六
========================
big bug:
软件每次启动需读取配置文件，若文件不存在，软件无法启动。
fix bug:
将配置文件作为资源文件，首次从资源读取。

2016-5-26 周四
========================
需求更改：
1、速度档位输入改为线速度输入(mm/s)，并转换成转速（rps）显示，
转换为档位百分比发给金；
2、程序文件持久化.

2016-5-27 周五
========================
1、完善程序载入和保存功能，并测试功能；
2、更换图标和应用图标
action icon: https://design.google.com/icons/
app icon: http://www.iconarchive.com/show/flatwoken-icons-by-alecive/Apps-Audio-Card-icon.html

2016-5-31 周二
=========================
考虑指令列表的修改需求实现：
1
双击选中后，指令编辑界面选中，加入按钮变为修改，提示修改参数
a 鼠标双击后如何判断是什么类型指令
b 选中指令行点击“修改”获取选中行类型及其参数输入入口

难度系数 a+++ b++
关键问题是：如何确定选中行是什么指令类型

任务分解：
1
QAbstractItemModel相关知识
2
QMouseEvent 鼠标事件，获取选中行
3
增加选中行信息维度
4
选中行信息相关操作，修改命令行参数

2016-6-2 周四
=========================
新需求：系统上电运行需要提醒或警告用户
鼠标事件
void mousePressEvent(QMouseEvent *e);
void mouseReleaseEvent(QMouseEvent *e);
void mouseDoubleClickEvent(QMouseEvent *e);

QT事件与信号的区别
事件实际上是事件列队，不同对象可能触发相同事件，所以有列队管理
信号可以具体到某个对象，即比事件更加精准

2016-6-4 周六
===========================
上周四研究发现无需通过监测鼠标事件实现修改指令功能，而是通过响应
QTableView单击或双击信号实现指令行修改。
具体怎么实现有些门道，需要认真考虑，一旦突破关键障碍，可能就不再是问题。

2016-6-6 周一
===========================
近期打算从该控制器项目退出，考虑到指令修改功能尚未实现，而且自己在逃避困难
两天周末时间没有投入时间解决问题，而是把时间用在MIT课程中，尽管从Python语言
数据处理和可视化课程中学习到不少知识，但归根结底还是在逃避问题。
那么，指令修改有哪些问题呢？
选中行所属指令类型如何标识，便于触发相应指令编辑工具栏
指令相关数据的更新问题，

2016-6-16 周四
===========================
思考程序的核心层，即两个概念或者数据结构：
指令
操作方法：
构造方法 - 根据指定类型生成通讯协议设计数据结构
整型数据转换为字符数组 int -> quint8[]
数组转换为串口通讯数据格式 quint8[] -> QByteArray

指令模型 管理指令序列
操作方法：
插入指令
修改指令
移动指令
删除指令
发送串口数据
保存指令文件
读取指令文件

注意：语言基础薄弱 核心层很难完成 支持性工作需要铺垫

2016-6-17 周五
=============================
重构指令数据，封装各种类型指令的数据构建。

接下来是重要的指令管理模型数据重构，比指令难些，实现指令序列
顺序加入
插入（前与后）
修改
移动
删除


2016-6-21 周二
==============================
别人往往只能看到结果，所以过程是自己，结果给别人尽量漂亮点
自定义数据角色（显示 可编辑 提示等等）
model->setData(model->index(row, 0), acmd.type(), Qt::UserRole);
model->setData(model->index(row, 1), acmd.type(), Qt::UserRole);

QModleIndex::data(int role = Qt::DisplayRole)
默认返回显示角色数据
QModleIndex::data(int role = Qt::UserRole)
即可显示自定义角色数据，比如指令类型编号
